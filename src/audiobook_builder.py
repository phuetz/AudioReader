"""
Construction d'audiobooks professionnels.

Fonctionnalités:
- Ajout de métadonnées MP3 (ID3 tags)
- Concaténation de chapitres
- Export M4B avec chapitrage
- Cohérence cross-chapitre
"""
import subprocess
import json
import tempfile
import shutil
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional
from datetime import datetime


@dataclass
class AudiobookMetadata:
    """Métadonnées de l'audiobook."""
    title: str
    author: str
    narrator: str = "Kokoro TTS"
    year: int = field(default_factory=lambda: datetime.now().year)
    genre: str = "Audiobook"
    description: str = ""
    cover_image: Optional[Path] = None
    language: str = "fr"


@dataclass
class ChapterInfo:
    """Information sur un chapitre."""
    number: int
    title: str
    audio_file: Path
    duration: float = 0.0  # en secondes
    start_time: float = 0.0  # position dans l'audiobook complet


def get_audio_duration(filepath: Path) -> float:
    """Récupère la durée d'un fichier audio en secondes."""
    try:
        cmd = [
            "ffprobe", "-v", "quiet",
            "-show_entries", "format=duration",
            "-of", "csv=p=0",
            str(filepath)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return float(result.stdout.strip())
    except (subprocess.CalledProcessError, ValueError, OSError) as e:
        # CalledProcessError: ffprobe a échoué
        # ValueError: conversion float impossible
        # OSError: ffprobe non trouvé
        return 0.0


def add_mp3_metadata(
    filepath: Path,
    metadata: AudiobookMetadata,
    chapter: ChapterInfo
) -> bool:
    """
    Ajoute les métadonnées ID3 à un fichier audio.

    Convertit en MP3 si nécessaire et ajoute les métadonnées.
    """
    try:
        # Déterminer si c'est un WAV ou MP3
        is_wav = filepath.suffix.lower() == '.wav'
        temp_file = filepath.with_suffix('.temp.mp3')

        if is_wav:
            # Encoder en MP3 avec métadonnées
            cmd = [
                "ffmpeg", "-y", "-i", str(filepath),
                "-b:a", "192k", "-ar", "44100", "-ac", "1",
                "-metadata", f"title={chapter.title}",
                "-metadata", f"artist={metadata.narrator}",
                "-metadata", f"album={metadata.title}",
                "-metadata", f"album_artist={metadata.author}",
                "-metadata", f"track={chapter.number}",
                "-metadata", f"genre={metadata.genre}",
                "-metadata", f"date={metadata.year}",
                "-metadata", f"language={metadata.language}",
                "-metadata", f"comment=Generated by AudioReader with Kokoro TTS",
                str(temp_file)
            ]
        else:
            # Copier avec métadonnées (MP3 existant)
            cmd = [
                "ffmpeg", "-y", "-i", str(filepath),
                "-c", "copy",
                "-metadata", f"title={chapter.title}",
                "-metadata", f"artist={metadata.narrator}",
                "-metadata", f"album={metadata.title}",
                "-metadata", f"album_artist={metadata.author}",
                "-metadata", f"track={chapter.number}",
                "-metadata", f"genre={metadata.genre}",
                "-metadata", f"date={metadata.year}",
                "-metadata", f"language={metadata.language}",
                "-metadata", f"comment=Generated by AudioReader with Kokoro TTS",
                str(temp_file)
            ]

        subprocess.run(cmd, check=True, capture_output=True)

        # Remplacer l'original par le MP3
        if is_wav:
            mp3_path = filepath.with_suffix('.mp3')
            temp_file.rename(mp3_path)
            # Mettre à jour le chemin dans chapter
            chapter.audio_file = mp3_path
        else:
            temp_file.replace(filepath)

        return True

    except subprocess.CalledProcessError as e:
        print(f"Erreur métadonnées: {e}")
        return False


def add_cover_art(filepath: Path, cover_image: Path) -> bool:
    """Ajoute une image de couverture au fichier audio."""
    if not cover_image.exists():
        return False

    try:
        temp_file = filepath.with_suffix('.temp.mp3')

        cmd = [
            "ffmpeg", "-y",
            "-i", str(filepath),
            "-i", str(cover_image),
            "-map", "0:a", "-map", "1:0",
            "-c", "copy",
            "-metadata:s:v", "title=Cover",
            "-metadata:s:v", "comment=Cover (front)",
            str(temp_file)
        ]

        subprocess.run(cmd, check=True, capture_output=True)
        temp_file.replace(filepath)
        return True

    except subprocess.CalledProcessError:
        return False


class AudiobookBuilder:
    """
    Constructeur d'audiobooks complets.

    Gère la concaténation, les métadonnées et l'export
    en différents formats (MP3, M4B).
    """

    def __init__(self, metadata: AudiobookMetadata):
        self.metadata = metadata
        self.chapters: list[ChapterInfo] = []

    def add_chapter(self, number: int, title: str, audio_file: Path):
        """Ajoute un chapitre à l'audiobook."""
        duration = get_audio_duration(audio_file)

        # Calculer le temps de départ
        start_time = sum(ch.duration for ch in self.chapters)

        chapter = ChapterInfo(
            number=number,
            title=title,
            audio_file=audio_file,
            duration=duration,
            start_time=start_time
        )

        self.chapters.append(chapter)

    def add_chapters_from_dir(self, directory: Path, pattern: str = "*.mp3"):
        """Ajoute tous les chapitres d'un dossier."""
        files = sorted(directory.glob(pattern))

        for i, filepath in enumerate(files, 1):
            # Extraire le titre du nom de fichier
            title = filepath.stem
            # Nettoyer le préfixe numérique si présent
            title = title.lstrip("0123456789_- ")

            self.add_chapter(i, title, filepath)

    def apply_metadata_to_all(self):
        """Applique les métadonnées à tous les chapitres."""
        for chapter in self.chapters:
            add_mp3_metadata(chapter.audio_file, self.metadata, chapter)

            if self.metadata.cover_image:
                add_cover_art(chapter.audio_file, self.metadata.cover_image)

    def get_total_duration(self) -> float:
        """Retourne la durée totale en secondes."""
        return sum(ch.duration for ch in self.chapters)

    def _generate_chapter_metadata(self) -> str:
        """Génère le fichier de métadonnées FFMETADATA pour les chapitres."""
        lines = [";FFMETADATA1"]
        lines.append(f"title={self.metadata.title}")
        lines.append(f"artist={self.metadata.author}")
        lines.append(f"album={self.metadata.title}")
        lines.append(f"genre={self.metadata.genre}")
        lines.append(f"date={self.metadata.year}")
        lines.append("")

        for chapter in self.chapters:
            start_ms = int(chapter.start_time * 1000)
            end_ms = int((chapter.start_time + chapter.duration) * 1000)

            lines.append("[CHAPTER]")
            lines.append("TIMEBASE=1/1000")
            lines.append(f"START={start_ms}")
            lines.append(f"END={end_ms}")
            lines.append(f"title={chapter.title}")
            lines.append("")

        return "\n".join(lines)

    def _generate_concat_file(self, temp_dir: Path) -> Path:
        """Génère le fichier de liste pour concaténation."""
        concat_file = temp_dir / "concat.txt"

        with open(concat_file, 'w', encoding='utf-8') as f:
            for chapter in self.chapters:
                # Échapper les apostrophes pour ffmpeg
                escaped_path = str(chapter.audio_file).replace("'", "'\\''")
                f.write(f"file '{escaped_path}'\n")

        return concat_file

    def build_m4b(self, output_path: Path) -> bool:
        """
        Construit un fichier M4B (audiobook avec chapitres).

        Le format M4B est le standard pour les audiobooks,
        supporté par Apple Books, iTunes, et la plupart des lecteurs.
        """
        if not self.chapters:
            print("Aucun chapitre à construire")
            return False

        temp_dir = Path(tempfile.mkdtemp())

        try:
            # 1. Convertir TOUS les fichiers en format uniforme (même codec, sample rate, channels)
            converted_files = []
            for i, chapter in enumerate(self.chapters):
                src = chapter.audio_file
                # Toujours convertir pour garantir des paramètres uniformes
                dst = temp_dir / f"chapter_{i:03d}.mp3"
                cmd = [
                    "ffmpeg", "-y", "-i", str(src),
                    "-b:a", "192k", "-ar", "44100", "-ac", "1",
                    str(dst)
                ]
                subprocess.run(cmd, check=True, capture_output=True)
                converted_files.append(dst)

            # 2. Créer le fichier de concaténation
            concat_file = temp_dir / "concat.txt"
            with open(concat_file, 'w', encoding='utf-8') as f:
                for fpath in converted_files:
                    # Utiliser des chemins absolus
                    escaped_path = str(fpath.absolute()).replace("'", "'\\''")
                    f.write(f"file '{escaped_path}'\n")

            # 3. Créer le fichier de métadonnées chapitres
            metadata_file = temp_dir / "metadata.txt"
            with open(metadata_file, 'w', encoding='utf-8') as f:
                f.write(self._generate_chapter_metadata())

            # 4. Concaténer les fichiers audio (re-encoder pour éviter les problèmes de compatibilité)
            combined_file = temp_dir / "combined.mp3"
            cmd_concat = [
                "ffmpeg", "-y",
                "-f", "concat",
                "-safe", "0",
                "-i", str(concat_file),
                "-b:a", "192k", "-ar", "44100", "-ac", "1",
                str(combined_file)
            ]
            subprocess.run(cmd_concat, check=True, capture_output=True)

            # 4. Convertir en M4B avec chapitres
            output_path.parent.mkdir(parents=True, exist_ok=True)

            cmd_m4b = [
                "ffmpeg", "-y",
                "-i", str(combined_file),
                "-i", str(metadata_file),
                "-map_metadata", "1",
                "-c:a", "aac",
                "-b:a", "128k",
                "-movflags", "+faststart",
                str(output_path)
            ]

            # Ajouter la couverture si disponible
            if self.metadata.cover_image and self.metadata.cover_image.exists():
                cmd_m4b = [
                    "ffmpeg", "-y",
                    "-i", str(combined_file),
                    "-i", str(metadata_file),
                    "-i", str(self.metadata.cover_image),
                    "-map", "0:a",
                    "-map", "2:v",
                    "-map_metadata", "1",
                    "-c:a", "aac",
                    "-b:a", "128k",
                    "-c:v", "copy",
                    "-disposition:v:0", "attached_pic",
                    "-movflags", "+faststart",
                    str(output_path)
                ]

            subprocess.run(cmd_m4b, check=True, capture_output=True)

            print(f"M4B créé: {output_path}")
            print(f"  Chapitres: {len(self.chapters)}")
            print(f"  Durée totale: {self.get_total_duration()/60:.1f} minutes")

            return True

        except subprocess.CalledProcessError as e:
            print(f"Erreur création M4B: {e}")
            return False

        finally:
            shutil.rmtree(temp_dir, ignore_errors=True)

    def build_combined_mp3(self, output_path: Path) -> bool:
        """
        Crée un seul fichier MP3 combiné.

        Note: Les chapitres ne seront pas navigables dans ce format.
        """
        if not self.chapters:
            print("Aucun chapitre à construire")
            return False

        temp_dir = Path(tempfile.mkdtemp())

        try:
            # Convertir tous les fichiers en format uniforme
            converted_files = []
            for i, chapter in enumerate(self.chapters):
                src = chapter.audio_file
                dst = temp_dir / f"chapter_{i:03d}.mp3"
                cmd = [
                    "ffmpeg", "-y", "-i", str(src),
                    "-b:a", "192k", "-ar", "44100", "-ac", "1",
                    str(dst)
                ]
                subprocess.run(cmd, check=True, capture_output=True)
                converted_files.append(dst)

            # Créer le fichier de concaténation
            concat_file = temp_dir / "concat.txt"
            with open(concat_file, 'w', encoding='utf-8') as f:
                for fpath in converted_files:
                    escaped_path = str(fpath.absolute()).replace("'", "'\\''")
                    f.write(f"file '{escaped_path}'\n")

            output_path.parent.mkdir(parents=True, exist_ok=True)

            cmd = [
                "ffmpeg", "-y",
                "-f", "concat",
                "-safe", "0",
                "-i", str(concat_file),
                "-b:a", "192k", "-ar", "44100", "-ac", "1",
                "-metadata", f"title={self.metadata.title}",
                "-metadata", f"artist={self.metadata.author}",
                "-metadata", f"album={self.metadata.title}",
                str(output_path)
            ]

            subprocess.run(cmd, check=True, capture_output=True)
            return True

        except subprocess.CalledProcessError as e:
            print(f"Erreur: {e}")
            return False

        finally:
            shutil.rmtree(temp_dir, ignore_errors=True)

    def print_summary(self):
        """Affiche un résumé de l'audiobook."""
        total_duration = self.get_total_duration()

        print(f"\n{'=' * 50}")
        print(f"  {self.metadata.title}")
        print(f"  par {self.metadata.author}")
        print(f"{'=' * 50}")
        print(f"\n  Narrateur: {self.metadata.narrator}")
        print(f"  Chapitres: {len(self.chapters)}")
        print(f"  Durée: {total_duration/60:.1f} minutes")
        print(f"\n  Chapitres:")

        for ch in self.chapters:
            mins = int(ch.duration // 60)
            secs = int(ch.duration % 60)
            print(f"    {ch.number:2}. {ch.title} ({mins}:{secs:02d})")


def build_audiobook_from_dir(
    audio_dir: Path,
    output_path: Path,
    title: str,
    author: str,
    narrator: str = "Kokoro TTS",
    cover_image: Optional[Path] = None,
    format: str = "m4b"
) -> bool:
    """
    Fonction utilitaire pour construire un audiobook complet.

    Args:
        audio_dir: Dossier contenant les fichiers MP3 des chapitres
        output_path: Chemin du fichier de sortie
        title: Titre de l'audiobook
        author: Auteur du livre
        narrator: Nom du narrateur
        cover_image: Image de couverture (optionnel)
        format: "m4b" ou "mp3"

    Returns:
        True si succès
    """
    metadata = AudiobookMetadata(
        title=title,
        author=author,
        narrator=narrator,
        cover_image=cover_image
    )

    builder = AudiobookBuilder(metadata)
    builder.add_chapters_from_dir(audio_dir)
    builder.apply_metadata_to_all()
    builder.print_summary()

    if format == "m4b":
        return builder.build_m4b(output_path)
    else:
        return builder.build_combined_mp3(output_path)
